/**
 * DragDropManager - Handles all drag and drop operations
 * ES6 Module version
 */

export class DragDropManager {
    constructor(app) {
        this.app = app;

        // Drag state
        this.draggedActionId = null;
        this.draggedCondition = null;
        this.conditionDropTarget = null;
        this.isDragging = false;
    }

    // ==================== Action Drag Operations ====================

    handleActionBlockDragStart(event, actionId) {
        event.stopPropagation();

        this.draggedActionId = actionId;
        this.isDragging = true;

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', actionId);
        event.dataTransfer.setData('actionId', actionId);

        const dragImage = event.target.closest('.action-item-wrapper');
        if (dragImage) {
            dragImage.classList.add('dragging');
            event.dataTransfer.setDragImage(dragImage, 20, 20);
        }
    }

    handleActionDragEnd(event) {
        this.draggedActionId = null;
        this.draggedCondition = null;
        this.isDragging = false;

        document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        this.removeDragPlaceholder();
    }

    handleContainerDragOver(event) {
        if (!this.draggedCondition && !this.draggedActionId) {
            return;
        }

        event.preventDefault();
        event.stopPropagation();
    }

    handleContainerDrop(event) {
        event.preventDefault();
        event.stopPropagation();

        if (this.draggedCondition) {
            const { parentActionId, conditionId } = this.draggedCondition;

            const parentAction = this.app.actions.find(a => a.id === parentActionId);
            if (!parentAction || !parentAction.conditions) {
                return;
            }

            const conditionIndex = parentAction.conditions.findIndex(c => c.id === conditionId);
            if (conditionIndex === -1) {
                return;
            }

            const condition = parentAction.conditions[conditionIndex];
            parentAction.conditions.splice(conditionIndex, 1);

            if (condition.actionType === 'image-match') {
                const hasImageMatch = parentAction.conditions.some(c => c.actionType === 'image-match');
                if (!hasImageMatch) {
                    const parentIndex = this.app.actions.findIndex(a => a.id === parentActionId);
                    const nextAction = this.app.actions[parentIndex + 1];
                    if (nextAction && nextAction.type === 'tap-matched-image' && nextAction.autoGenerated) {
                        this.app.actions.splice(parentIndex + 1, 1);
                        this.app.addLog('info', '찾은 영역 클릭 액션이 자동으로 제거되었습니다');
                    }
                }
            }

            const newAction = {
                id: `action-${Date.now()}`,
                type: condition.actionType,
                ...condition.params
            };

            this.app.actions.push(newAction);
            this.draggedCondition = null;

            this.app.renderActionSequence();
            this.app.saveToLocalStorage();
        } else if (this.draggedActionId) {
            const draggedIndex = this.app.actions.findIndex(a => a.id === this.draggedActionId);
            if (draggedIndex !== -1) {
                const [draggedAction] = this.app.actions.splice(draggedIndex, 1);
                this.app.actions.push(draggedAction);
                this.app.renderActionSequence();
                this.app.saveToLocalStorage();
            }
        }
    }

    handleActionDragOver(event, targetActionId) {
        event.preventDefault();
        event.stopPropagation();

        if (this.draggedCondition) {
            this._handleConditionDragOverAction(event, targetActionId);
            return;
        }

        const draggedActionId = this.draggedActionId || event.dataTransfer.getData('actionId');
        if (!draggedActionId || draggedActionId === targetActionId) return;

        const draggedIndex = this.app.actions.findIndex(a => a.id === draggedActionId);
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);

        if (draggedIndex === -1 || targetIndex === -1) return;

        const targetElement = event.currentTarget;
        const rect = targetElement.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const isAfter = event.clientY > midpoint;

        if (!isAfter && targetIndex === draggedIndex + 1) return;
        if (isAfter && targetIndex === draggedIndex - 1) return;

        this.removeDragPlaceholder();
        this._createPlaceholder(targetElement, targetActionId, isAfter, true);
    }

    _handleConditionDragOverAction(event, targetActionId) {
        const targetElement = event.currentTarget;
        const actionBlock = targetElement.querySelector('.action-block');
        if (!actionBlock) return;

        const rect = actionBlock.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const isAfter = event.clientY > midpoint;

        this.removeDragPlaceholder();
        this._createPlaceholder(targetElement, targetActionId, isAfter, false);
    }

    _createPlaceholder(targetElement, targetActionId, isAfter, isAction) {
        const placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.setAttribute('data-target-id', targetActionId);
        placeholder.setAttribute('data-insert-after', isAfter);
        placeholder.style.cssText = `
            height: ${isAction ? '80px' : '60px'};
            margin: ${isAction ? '12px' : '8px'} 0;
            border: 3px dashed #3b82f6;
            border-radius: ${isAction ? '12px' : '8px'};
            background: rgba(59, 130, 246, 0.08);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            animation: placeholderPulse 1.5s ease-in-out infinite;
        `;

        if (isAction) {
            placeholder.addEventListener('dragover', (e) => e.preventDefault());
            placeholder.addEventListener('drop', (e) => {
                this.handleActionDropOnPlaceholder(e, targetActionId, isAfter);
            });
        }

        const wrapper = targetElement.closest('.action-item-wrapper');
        if (wrapper) {
            if (isAfter) {
                wrapper.after(placeholder);
            } else {
                wrapper.before(placeholder);
            }
        }
    }

    handleActionDragLeave(event, targetActionId) {
        // Placeholder handled globally
    }

    handleActionDropOnPlaceholder(event, targetActionId, insertAfter) {
        const draggedActionId = this.draggedActionId || event.dataTransfer.getData('actionId');
        if (!draggedActionId || draggedActionId === targetActionId) {
            this.removeDragPlaceholder();
            return;
        }

        const draggedIndex = this.app.actions.findIndex(a => a.id === draggedActionId);
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);

        if (draggedIndex === -1 || targetIndex === -1) {
            this.removeDragPlaceholder();
            return;
        }

        const draggedAction = this.app.actions[draggedIndex];
        let blocksToMove = [draggedAction];
        let pairAction = null;

        if (draggedAction.pairId) {
            pairAction = this.app.actions.find(a => a.pairId === draggedAction.pairId && a.id !== draggedAction.id);
            if (pairAction) {
                blocksToMove.push(pairAction);
            }
        }

        blocksToMove.forEach(block => {
            const idx = this.app.actions.findIndex(a => a.id === block.id);
            if (idx !== -1) {
                this.app.actions.splice(idx, 1);
            }
        });

        let insertIndex = this.app.actions.findIndex(a => a.id === targetActionId);
        if (insertIndex === -1) {
            insertIndex = this.app.actions.length;
        } else if (insertAfter) {
            insertIndex++;
        }

        blocksToMove.sort((a, b) => {
            if (a.type && a.type.endsWith('-start')) return -1;
            if (b.type && b.type.endsWith('-start')) return 1;
            return 0;
        });

        blocksToMove.forEach((block, i) => {
            this.app.actions.splice(insertIndex + i, 0, block);
        });

        this.removeDragPlaceholder();
        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    handleActionDrop(event, targetActionId) {
        event.preventDefault();
        event.stopPropagation();

        const isConditionDrag = event.dataTransfer.getData('conditionDrag') === 'true';

        if (isConditionDrag || this.draggedCondition) {
            this.handleConditionToActionDrop(event, targetActionId);
            return;
        }

        const draggedActionId = this.draggedActionId || event.dataTransfer.getData('actionId');
        if (!draggedActionId || draggedActionId === targetActionId) return;

        const draggedIndex = this.app.actions.findIndex(a => a.id === draggedActionId);
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);

        if (draggedIndex === -1 || targetIndex === -1) return;

        const draggedAction = this.app.actions[draggedIndex];
        let blocksToMove = [draggedAction];

        if (draggedAction.pairId) {
            const pairAction = this.app.actions.find(a => a.pairId === draggedAction.pairId && a.id !== draggedAction.id);
            if (pairAction) {
                blocksToMove.push(pairAction);
            }
        }

        blocksToMove.forEach(block => {
            const idx = this.app.actions.findIndex(a => a.id === block.id);
            if (idx !== -1) {
                this.app.actions.splice(idx, 1);
            }
        });

        let newTargetIndex = this.app.actions.findIndex(a => a.id === targetActionId);
        if (newTargetIndex === -1) {
            newTargetIndex = this.app.actions.length;
        }

        blocksToMove.sort((a, b) => {
            if (a.type && a.type.endsWith('-start')) return -1;
            if (b.type && b.type.endsWith('-start')) return 1;
            return 0;
        });

        blocksToMove.forEach((block, i) => {
            this.app.actions.splice(newTargetIndex + i, 0, block);
        });

        this.removeDragPlaceholder();
        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    // ==================== Condition Drag Operations ====================

    handleConditionDragStart(event, parentActionId, conditionId) {
        event.stopPropagation();
        this.draggedCondition = { parentActionId, conditionId };

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', conditionId);
        event.dataTransfer.setData('conditionDrag', 'true');
    }

    handleConditionDragOver(event, parentActionId, targetConditionId) {
        event.preventDefault();
        event.stopPropagation();

        if (!this.draggedCondition) return;
        if (this.draggedCondition.conditionId === targetConditionId) return;
        if (this.draggedCondition.parentActionId !== parentActionId) return;

        const targetElement = event.currentTarget;
        const rect = targetElement.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const isAfter = event.clientY > midpoint;

        this.removeDragPlaceholder();

        const placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.style.cssText = `
            height: 60px;
            margin: 8px 0;
            border: 3px dashed #3b82f6;
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.08);
        `;

        this.conditionDropTarget = { parentActionId, targetConditionId, isAfter };

        if (isAfter) {
            targetElement.after(placeholder);
        } else {
            targetElement.before(placeholder);
        }
    }

    handleConditionDragLeave(event, parentActionId, conditionId) {
        // Placeholder cleanup handled globally
    }

    handleConditionDrop(event, parentActionId, targetConditionId) {
        event.preventDefault();
        event.stopPropagation();

        this.removeDragPlaceholder();

        if (!this.draggedCondition) return;
        if (!this.conditionDropTarget) return;

        const { parentActionId: sourceParentId, conditionId } = this.draggedCondition;

        if (sourceParentId !== parentActionId) {
            this.draggedCondition = null;
            this.conditionDropTarget = null;
            return;
        }

        const action = this.app.actions.find(a => a.id === parentActionId);
        if (!action || !action.conditions) {
            this.draggedCondition = null;
            this.conditionDropTarget = null;
            return;
        }

        const fromIndex = action.conditions.findIndex(c => c.id === conditionId);
        const toIndex = action.conditions.findIndex(c => c.id === targetConditionId);

        if (fromIndex === -1 || toIndex === -1 || fromIndex === toIndex) {
            this.draggedCondition = null;
            this.conditionDropTarget = null;
            return;
        }

        const [movedCondition] = action.conditions.splice(fromIndex, 1);
        const insertIndex = this.conditionDropTarget.isAfter ? toIndex : Math.max(0, toIndex);
        action.conditions.splice(insertIndex, 0, movedCondition);

        this.draggedCondition = null;
        this.conditionDropTarget = null;

        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    handleConditionToActionDrop(event, targetActionId) {
        this.removeDragPlaceholder();

        if (!this.draggedCondition) return;

        const { parentActionId, conditionId } = this.draggedCondition;

        const parentAction = this.app.actions.find(a => a.id === parentActionId);
        if (!parentAction || !parentAction.conditions) return;

        const conditionIndex = parentAction.conditions.findIndex(c => c.id === conditionId);
        if (conditionIndex === -1) return;

        const condition = parentAction.conditions[conditionIndex];

        const newAction = {
            id: `action-${Date.now()}`,
            type: condition.actionType,
            ...condition.params
        };

        parentAction.conditions.splice(conditionIndex, 1);

        if (condition.actionType === 'image-match') {
            const hasImageMatch = parentAction.conditions.some(c => c.actionType === 'image-match');
            if (!hasImageMatch) {
                const parentIndex = this.app.actions.findIndex(a => a.id === parentActionId);
                const nextAction = this.app.actions[parentIndex + 1];
                if (nextAction && nextAction.type === 'tap-matched-image' && nextAction.autoGenerated) {
                    this.app.actions.splice(parentIndex + 1, 1);
                    this.app.addLog('info', '찾은 영역 클릭 액션이 자동으로 제거되었습니다');
                }
            }
        }

        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);
        if (targetIndex !== -1) {
            this.app.actions.splice(targetIndex + 1, 0, newAction);
        } else {
            this.app.actions.push(newAction);
        }

        this.draggedCondition = null;
        this.conditionDropTarget = null;

        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    // ==================== Utility ====================

    removeDragPlaceholder() {
        document.querySelectorAll('.drag-placeholder').forEach(el => el.remove());
    }

    resetDragState() {
        this.draggedActionId = null;
        this.draggedCondition = null;
        this.conditionDropTarget = null;
        this.isDragging = false;
        this.removeDragPlaceholder();
    }
}

export default DragDropManager;
