/**
 * DragDropManager - Handles all drag and drop operations for actions and conditions
 * Extracted from macro-builder-app.js for better modularity
 */

class DragDropManager {
    constructor(app) {
        this.app = app;

        // Drag state
        this.draggedActionId = null;
        this.draggedCondition = null;
        this.conditionDropTarget = null;
        this.isDragging = false;
    }

    // ==================== Action Drag Operations ====================

    /**
     * Handle action block drag start
     */
    handleActionBlockDragStart(event, actionId) {
        event.stopPropagation();

        this.draggedActionId = actionId;
        this.isDragging = true;

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', actionId);
        event.dataTransfer.setData('actionId', actionId);

        // Add visual feedback
        const dragImage = event.target.closest('.action-item-wrapper');
        if (dragImage) {
            dragImage.classList.add('dragging');
            event.dataTransfer.setDragImage(dragImage, 20, 20);
        }
    }

    /**
     * Handle action drag end
     */
    handleActionDragEnd(event) {
        this.draggedActionId = null;
        this.draggedCondition = null;
        this.isDragging = false;

        // Remove all dragging classes
        document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        // Remove placeholders
        this.removeDragPlaceholder();
    }

    /**
     * Handle drag over empty container area
     */
    handleContainerDragOver(event) {
        if (!this.draggedCondition && !this.draggedActionId) {
            return;
        }

        event.preventDefault();
        event.stopPropagation();
    }

    /**
     * Handle drop on empty container area
     */
    handleContainerDrop(event) {
        event.preventDefault();
        event.stopPropagation();

        // Handle condition drop (convert to action)
        if (this.draggedCondition) {
            const { parentActionId, conditionId } = this.draggedCondition;

            const parentAction = this.app.actions.find(a => a.id === parentActionId);
            if (!parentAction || !parentAction.conditions) {
                return;
            }

            const conditionIndex = parentAction.conditions.findIndex(c => c.id === conditionId);
            if (conditionIndex === -1) {
                return;
            }

            const condition = parentAction.conditions[conditionIndex];
            parentAction.conditions.splice(conditionIndex, 1);

            // Check if we need to remove auto-generated tap-matched-image
            if (condition.actionType === 'image-match') {
                const hasImageMatch = parentAction.conditions.some(c => c.actionType === 'image-match');
                if (!hasImageMatch) {
                    const parentIndex = this.app.actions.findIndex(a => a.id === parentActionId);
                    const nextAction = this.app.actions[parentIndex + 1];
                    if (nextAction && nextAction.type === 'tap-matched-image' && nextAction.autoGenerated) {
                        this.app.actions.splice(parentIndex + 1, 1);
                        this.app.addLog('info', '찾은 영역 클릭 액션이 자동으로 제거되었습니다');
                    }
                }
            }

            // Convert condition to action
            const newAction = {
                id: `action-${Date.now()}`,
                type: condition.actionType,
                ...condition.params
            };

            this.app.actions.push(newAction);
            this.draggedCondition = null;

            this.app.renderActionSequence();
            this.app.saveToLocalStorage();
        }
        // Handle regular action drop
        else if (this.draggedActionId) {
            const draggedIndex = this.app.actions.findIndex(a => a.id === this.draggedActionId);
            if (draggedIndex !== -1) {
                const [draggedAction] = this.app.actions.splice(draggedIndex, 1);
                this.app.actions.push(draggedAction);
                this.app.renderActionSequence();
                this.app.saveToLocalStorage();
            }
        }
    }

    /**
     * Handle drag over action item
     */
    handleActionDragOver(event, targetActionId) {
        event.preventDefault();
        event.stopPropagation();

        // Handle condition drag over action
        if (this.draggedCondition) {
            const targetElement = event.currentTarget;
            const actionBlock = targetElement.querySelector('.action-block');
            if (!actionBlock) return;

            const rect = actionBlock.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAfter = event.clientY > midpoint;

            this.removeDragPlaceholder();

            // Create placeholder
            const placeholder = document.createElement('div');
            placeholder.className = 'drag-placeholder';
            placeholder.setAttribute('data-target-id', targetActionId);
            placeholder.setAttribute('data-insert-after', isAfter);
            placeholder.style.cssText = `
                height: 80px;
                margin: 12px 0;
                border: 3px dashed #3b82f6;
                border-radius: 12px;
                background: rgba(59, 130, 246, 0.08);
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
                animation: placeholderPulse 1.5s ease-in-out infinite;
            `;

            const wrapper = targetElement.closest('.action-item-wrapper');
            if (wrapper) {
                if (isAfter) {
                    wrapper.after(placeholder);
                } else {
                    wrapper.before(placeholder);
                }
            }

            return;
        }

        // Handle action drag over action
        const draggedActionId = this.draggedActionId || event.dataTransfer.getData('actionId');
        if (!draggedActionId || draggedActionId === targetActionId) return;

        const draggedIndex = this.app.actions.findIndex(a => a.id === draggedActionId);
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);

        if (draggedIndex === -1 || targetIndex === -1) return;

        const targetElement = event.currentTarget;
        const rect = targetElement.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const isAfter = event.clientY > midpoint;

        // Skip if would result in no movement
        if (!isAfter && targetIndex === draggedIndex + 1) return;
        if (isAfter && targetIndex === draggedIndex - 1) return;

        this.removeDragPlaceholder();

        // Create placeholder
        const placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.setAttribute('data-target-id', targetActionId);
        placeholder.setAttribute('data-insert-after', isAfter);
        placeholder.style.cssText = `
            height: 80px;
            margin: 12px 0;
            border: 3px dashed #3b82f6;
            border-radius: 12px;
            background: rgba(59, 130, 246, 0.08);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            animation: placeholderPulse 1.5s ease-in-out infinite;
        `;

        // Add drop handler
        placeholder.addEventListener('dragover', (e) => e.preventDefault());
        placeholder.addEventListener('drop', (e) => {
            this.handleActionDropOnPlaceholder(e, targetActionId, isAfter);
        });

        const wrapper = targetElement.closest('.action-item-wrapper');
        if (wrapper) {
            if (isAfter) {
                wrapper.after(placeholder);
            } else {
                wrapper.before(placeholder);
            }
        }
    }

    /**
     * Handle action drag leave
     */
    handleActionDragLeave(event, targetActionId) {
        // Placeholder is handled globally
    }

    /**
     * Handle action drop on placeholder
     */
    handleActionDropOnPlaceholder(event, targetActionId, insertAfter) {
        const draggedActionId = this.draggedActionId || event.dataTransfer.getData('actionId');
        if (!draggedActionId || draggedActionId === targetActionId) {
            this.removeDragPlaceholder();
            return;
        }

        const draggedIndex = this.app.actions.findIndex(a => a.id === draggedActionId);
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);

        if (draggedIndex === -1 || targetIndex === -1) {
            this.removeDragPlaceholder();
            return;
        }

        const draggedAction = this.app.actions[draggedIndex];
        let blocksToMove = [draggedAction];
        let pairAction = null;

        // Handle paired actions (like loop-start/loop-end)
        if (draggedAction.pairId) {
            pairAction = this.app.actions.find(a => a.pairId === draggedAction.pairId && a.id !== draggedAction.id);
            if (pairAction) {
                blocksToMove.push(pairAction);
            }
        }

        // Remove blocks from current positions
        blocksToMove.forEach(block => {
            const idx = this.app.actions.findIndex(a => a.id === block.id);
            if (idx !== -1) {
                this.app.actions.splice(idx, 1);
            }
        });

        // Calculate new insert position
        let insertIndex = this.app.actions.findIndex(a => a.id === targetActionId);
        if (insertIndex === -1) {
            insertIndex = this.app.actions.length;
        } else if (insertAfter) {
            insertIndex++;
        }

        // Insert blocks at new position
        blocksToMove.sort((a, b) => {
            if (a.type && a.type.endsWith('-start')) return -1;
            if (b.type && b.type.endsWith('-start')) return 1;
            return 0;
        });

        blocksToMove.forEach((block, i) => {
            this.app.actions.splice(insertIndex + i, 0, block);
        });

        this.removeDragPlaceholder();
        this.app.renderActionSequence();
        this.app.saveToLocalStorage();

        console.log(`Reordered: moved ${blocksToMove.length} block(s) to position ${insertIndex}`);
    }

    /**
     * Handle action drop
     */
    handleActionDrop(event, targetActionId) {
        event.preventDefault();
        event.stopPropagation();

        // Check if condition is being dragged
        const isConditionDrag = event.dataTransfer.getData('conditionDrag') === 'true';

        if (isConditionDrag || this.draggedCondition) {
            this.handleConditionToActionDrop(event, targetActionId);
            return;
        }

        const draggedActionId = this.draggedActionId || event.dataTransfer.getData('actionId');
        if (!draggedActionId || draggedActionId === targetActionId) return;

        const draggedIndex = this.app.actions.findIndex(a => a.id === draggedActionId);
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);

        if (draggedIndex === -1 || targetIndex === -1) return;

        const draggedAction = this.app.actions[draggedIndex];
        let blocksToMove = [draggedAction];
        let pairAction = null;

        if (draggedAction.pairId) {
            pairAction = this.app.actions.find(a => a.pairId === draggedAction.pairId && a.id !== draggedAction.id);
            if (pairAction) {
                blocksToMove.push(pairAction);
            }
        }

        // Remove and reinsert
        blocksToMove.forEach(block => {
            const idx = this.app.actions.findIndex(a => a.id === block.id);
            if (idx !== -1) {
                this.app.actions.splice(idx, 1);
            }
        });

        let newTargetIndex = this.app.actions.findIndex(a => a.id === targetActionId);
        if (newTargetIndex === -1) {
            newTargetIndex = this.app.actions.length;
        }

        blocksToMove.sort((a, b) => {
            if (a.type && a.type.endsWith('-start')) return -1;
            if (b.type && b.type.endsWith('-start')) return 1;
            return 0;
        });

        blocksToMove.forEach((block, i) => {
            this.app.actions.splice(newTargetIndex + i, 0, block);
        });

        this.removeDragPlaceholder();
        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    // ==================== Condition Drag Operations ====================

    /**
     * Handle condition drag start
     */
    handleConditionDragStart(event, parentActionId, conditionId) {
        event.stopPropagation();
        this.draggedCondition = { parentActionId, conditionId };

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', conditionId);
        event.dataTransfer.setData('conditionDrag', 'true');
    }

    /**
     * Handle condition drag over
     */
    handleConditionDragOver(event, parentActionId, targetConditionId) {
        event.preventDefault();
        event.stopPropagation();

        if (!this.draggedCondition) return;

        // Can't drop on itself
        if (this.draggedCondition.conditionId === targetConditionId) return;

        // Can only reorder within same parent
        if (this.draggedCondition.parentActionId !== parentActionId) return;

        const targetElement = event.currentTarget;
        const rect = targetElement.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const isAfter = event.clientY > midpoint;

        this.removeDragPlaceholder();

        // Create placeholder
        const placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.style.cssText = `
            height: 60px;
            margin: 8px 0;
            border: 3px dashed #3b82f6;
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.08);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            animation: placeholderPulse 1.5s ease-in-out infinite;
        `;

        this.conditionDropTarget = { parentActionId, targetConditionId, isAfter };

        if (isAfter) {
            targetElement.after(placeholder);
        } else {
            targetElement.before(placeholder);
        }
    }

    /**
     * Handle condition drag leave
     */
    handleConditionDragLeave(event, parentActionId, conditionId) {
        // Placeholder cleanup handled globally
    }

    /**
     * Handle condition drop (reorder within same parent)
     */
    handleConditionDrop(event, parentActionId, targetConditionId) {
        event.preventDefault();
        event.stopPropagation();

        this.removeDragPlaceholder();

        if (!this.draggedCondition) return;
        if (!this.conditionDropTarget) return;

        const { parentActionId: sourceParentId, conditionId } = this.draggedCondition;

        // Only handle reordering within same parent
        if (sourceParentId !== parentActionId) {
            this.draggedCondition = null;
            this.conditionDropTarget = null;
            return;
        }

        const action = this.app.actions.find(a => a.id === parentActionId);
        if (!action || !action.conditions) {
            this.draggedCondition = null;
            this.conditionDropTarget = null;
            return;
        }

        const fromIndex = action.conditions.findIndex(c => c.id === conditionId);
        const toIndex = action.conditions.findIndex(c => c.id === targetConditionId);

        if (fromIndex === -1 || toIndex === -1 || fromIndex === toIndex) {
            this.draggedCondition = null;
            this.conditionDropTarget = null;
            return;
        }

        // Reorder
        const [movedCondition] = action.conditions.splice(fromIndex, 1);
        const insertIndex = this.conditionDropTarget.isAfter ? toIndex : Math.max(0, toIndex);
        action.conditions.splice(insertIndex, 0, movedCondition);

        this.draggedCondition = null;
        this.conditionDropTarget = null;

        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    /**
     * Handle condition dropped on action (convert to action)
     */
    handleConditionToActionDrop(event, targetActionId) {
        this.removeDragPlaceholder();

        if (!this.draggedCondition) return;

        const { parentActionId, conditionId } = this.draggedCondition;

        const parentAction = this.app.actions.find(a => a.id === parentActionId);
        if (!parentAction || !parentAction.conditions) return;

        const conditionIndex = parentAction.conditions.findIndex(c => c.id === conditionId);
        if (conditionIndex === -1) return;

        const condition = parentAction.conditions[conditionIndex];

        // Create new action from condition
        const newAction = {
            id: `action-${Date.now()}`,
            type: condition.actionType,
            ...condition.params
        };

        // Remove condition from parent
        parentAction.conditions.splice(conditionIndex, 1);

        // Check if need to remove auto-generated tap-matched-image
        if (condition.actionType === 'image-match') {
            const hasImageMatch = parentAction.conditions.some(c => c.actionType === 'image-match');
            if (!hasImageMatch) {
                const parentIndex = this.app.actions.findIndex(a => a.id === parentActionId);
                const nextAction = this.app.actions[parentIndex + 1];
                if (nextAction && nextAction.type === 'tap-matched-image' && nextAction.autoGenerated) {
                    this.app.actions.splice(parentIndex + 1, 1);
                    this.app.addLog('info', '찾은 영역 클릭 액션이 자동으로 제거되었습니다');
                }
            }
        }

        // Find insert position
        const targetIndex = this.app.actions.findIndex(a => a.id === targetActionId);
        if (targetIndex !== -1) {
            this.app.actions.splice(targetIndex + 1, 0, newAction);
        } else {
            this.app.actions.push(newAction);
        }

        this.draggedCondition = null;
        this.conditionDropTarget = null;

        this.app.renderActionSequence();
        this.app.saveToLocalStorage();
    }

    // ==================== Utility ====================

    /**
     * Remove all drag placeholders
     */
    removeDragPlaceholder() {
        document.querySelectorAll('.drag-placeholder').forEach(el => el.remove());
    }

    /**
     * Reset drag state
     */
    resetDragState() {
        this.draggedActionId = null;
        this.draggedCondition = null;
        this.conditionDropTarget = null;
        this.isDragging = false;
        this.removeDragPlaceholder();
    }
}

// Export for use
window.DragDropManager = DragDropManager;
